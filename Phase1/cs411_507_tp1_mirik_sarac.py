# -*- coding: utf-8 -*-
"""client.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q664jZtMNLS7XDO3o-gwFZxiMeJqz2Rm
"""

import math
import time
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, HMAC, SHA256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json

E = Curve.get_curve('secp256k1')
n = E.order
p = E.field
P = E.generator
a = E.a
b = E.b

API_URL = 'http://10.92.55.4:5000'

stuID = 28374 #Enter Your ID

#Server's Identitiy public key
IKey_Ser = Point(0xce1a69ecc226f9e667856ce37a44e50dbea3d58e3558078baee8fe5e017a556d, 0x13ddaf97158206b1d80258d7f6a6880e7aaf13180e060bb1e94174e419a4a093, E)
# Use the values in the project description document to form the server's IK as a point on the EC. Note that the values should be in decimal.

def IKRegReq(h,s,x,y):
    mes = {'ID':stuID, 'H': h, 'S': s, 'IKPUB.X': x, 'IKPUB.Y': y}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "IKRegReq"), json = mes)		
    if((response.ok) == False): print(response.json())

def IKRegVerify(code):
    mes = {'ID':stuID, 'CODE': code}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "IKRegVerif"), json = mes)
    if((response.ok) == False): raise Exception(response.json())
    else:
        print(response.json())
        f = open('Identity_Key.txt', 'w')
        f.write("IK.Prv: "+str(IKey_Pr)+"\n"+"IK.Pub.x: "+str(IKey_Pub.x)+"\n"+"IK.Pub.y: "+str(IKey_Pub.y))
        f.close()

def SPKReg(h,s,x,y):
    mes = {'ID':stuID, 'H': h, 'S': s, 'SPKPUB.X': x, 'SPKPUB.Y': y}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "SPKReg"), json = mes)		
    if((response.ok) == False): 
        print(response.json())
    else: 
        res = response.json()
        return res['SPKPUB.X'], res['SPKPUB.Y'], res['H'], res['S']

def OTKReg(keyID,x,y,hmac):
    mes = {'ID':stuID, 'KEYID': keyID, 'OTKI.X': x, 'OTKI.Y': y, 'HMACI': hmac}
    print("Sending message is: ", mes)
    response = requests.put('{}/{}'.format(API_URL, "OTKReg"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True


def ResetIK(rcode):
    mes = {'ID':stuID, 'RCODE': rcode}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetIK"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True

def ResetSPK(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetSPK"), json = mes)		
    print(response.json())
    if((response.ok) == False): return False
    else: return True


def ResetOTK(h,s):
    mes = {'ID':stuID, 'H': h, 'S': s}
    print("Sending message is: ", mes)
    response = requests.delete('{}/{}'.format(API_URL, "ResetOTK"), json = mes)		
    if((response.ok) == False): print(response.json())

def GenerateKey():
  pri = random.randint(0,n-1)
  pub = pri * P
  return pri, pub

IKey_Pr = int.from_bytes(b"this is my secret", byteorder="big") % n
IKey_Pub = IKey_Pr * P

def SignMessage(m):
  k = random.randint(1, n-2)

  R = k * P
  r = R.x % n

  r_bytes = r.to_bytes(math.ceil(r.bit_length()/8), 'big')
  if isinstance(m, int):
    m = m.to_bytes(math.ceil(m.bit_length()/8), 'big')
  
  h = SHA3_256.new(r_bytes + m)
  h = h.digest()
  h = int.from_bytes(h,"big")
  h = h % n
  
  s = (k + IKey_Pr * h) % n
  
  return h, s

def VerifySignature(m, h, s, Key_Pub):
  V = s * P - h * Key_Pub
  v = V.x % n

  v_bytes = v.to_bytes(math.ceil(v.bit_length()/8), 'big')
  if isinstance(m, int):
    m = m.to_bytes(math.ceil(m.bit_length()/8), 'big')

  h2 = SHA3_256.new(v_bytes + m)
  h2 = h2.digest()
  h2 = int.from_bytes(h2,"big") % n
  h2 = h2 % n
  return h2 == h

h, s = SignMessage(stuID)

VerifySignature(stuID, h, s, IKey_Pub)

IKRegReq(h, s, IKey_Pub.x, IKey_Pub.y)

CODE = 462614

IKRegVerify(CODE)

RCODE = 740117

SPK_A_Pri, SPK_A_Pub = GenerateKey(33232637425696107713632882735238964086585438341980536407357193648214666452195)

SPK_A_message = SPK_A_Pub.x.to_bytes(math.ceil(SPK_A_Pub.x.bit_length()/8), 'big') + SPK_A_Pub.y.to_bytes(math.ceil(SPK_A_Pub.y.bit_length()/8), 'big')
SPK_A_h, SPK_A_s = SignMessage(SPK_A_message)

SPK_S_X, SPK_S_Y, SPK_S_h, SPK_S_s = SPKReg(SPK_A_h, SPK_A_s, SPK_A_Pub.x, SPK_A_Pub.y)
SPK_S_Pub = Point(SPK_S_X, SPK_S_Y, E)

SPK_S_message = SPK_S_Pub.x.to_bytes(math.ceil(SPK_S_Pub.x.bit_length()/8), 'big') + SPK_S_Pub.y.to_bytes(math.ceil(SPK_S_Pub.y.bit_length()/8), 'big')

VerifySignature(SPK_S_message, SPK_S_h, SPK_S_s, IKey_Ser)

# Generate HMAX Key
T = SPK_A_Pri * SPK_S_Pub
U = b'CuriosityIsTheHMACKeyToCreativity' + T.y.to_bytes(math.ceil(T.y.bit_length()/8), 'big') + T.x.to_bytes(math.ceil(T.x.bit_length()/8), 'big')
K_HMAC = SHA3_256.new(U).digest()

# Generate OTKs
OTKs=[]
for i in range(10):
  priv, pub = GenerateKey()
  m = pub.x.to_bytes(math.ceil(pub.x.bit_length()/8), 'big') + pub.y.to_bytes(math.ceil(pub.y.bit_length()/8), 'big')
  hmaci = HMAC.new(K_HMAC, m, digestmod=SHA256).hexdigest()
  OTKReg(i, pub.x, pub.y, hmaci)
  OTKs.append((priv, pub))

with open("otks.txt", "w+") as f:
  for otk in OTKs:
    f.write(f"{otk[0]} {otk[1].x} {otk[1].y}\n")